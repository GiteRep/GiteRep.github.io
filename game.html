<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tiny HTML RPG</title>
<style>
  :root{
    --bg:#0e1013; --panel:#171a1f; --muted:#8b95a7; --bright:#e2e8f0;
    --accent:#7c3aed; --accent-2:#22c55e; --danger:#ef4444; --gold:#f59e0b;
    --tile:#202531; --tile-2:#1a1f2b; --grid:#283041;
    --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    --ui: system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background: radial-gradient(1200px 800px at 20% 0%, #121828, #0b0d12 60%) fixed;
    color:var(--bright); font-family:var(--ui); display:flex; align-items:center; justify-content:center; padding:14px;
  }
  .app{
    display:grid; gap:12px; width:min(1000px, 100vw); grid-template-columns: 1fr 320px;
  }
  header{
    grid-column:1/-1; background:linear-gradient(180deg,#1b2030,#121723);
    border:1px solid #2a3347; border-radius:12px; padding:10px 12px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    box-shadow: 0 8px 24px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.04);
  }
  header .stat{display:flex; align-items:center; gap:8px; background:#121622; border:1px solid #2a3347; padding:6px 10px; border-radius:10px;}
  .hpbar{height:10px; width:140px; background:#261b1b; border-radius:8px; overflow:hidden; border:1px solid #3b2b2b}
  .hpbar > i{display:block; height:100%; background:linear-gradient(90deg,#ef4444,#f97316); width:100%}
  .xpbar{height:10px; width:140px; background:#1a1b2d; border-radius:8px; overflow:hidden; border:1px solid #2e3050}
  .xpbar > i{display:block; height:100%; background:linear-gradient(90deg,#7c3aed,#22d3ee); width:0%}
  .pill {font-weight:600; font-variant-numeric:tabular-nums}
  .gold{color:var(--gold)}
  main{
    display:grid; grid-template-rows:auto 1fr; gap:12px;
  }
  .viewport{
    background:repeating-linear-gradient(0deg,var(--tile),var(--tile) 32px,var(--tile-2) 32px,var(--tile-2) 64px);
    border:1px solid #2a3347; border-radius:12px; padding:10px; position:relative;
    box-shadow: inset 0 0 0 1px #283041, 0 10px 40px rgba(0,0,0,.35);
  }
  canvas{display:block; width:100%; height:auto; image-rendering: pixelated}
  .right{
    display:grid; grid-template-rows:auto 1fr auto; gap:12px;
  }
  .panel{
    background:var(--panel); border:1px solid #2a3347; border-radius:12px; padding:12px;
    box-shadow:inset 0 1px 0 rgba(255,255,255,.04);
  }
  .panel h3{margin:0 0 8px 0; font-size:15px; color:#cdd6e5}
  .log{height:240px; overflow:auto; font-family:var(--mono); background:#0f1420; border-radius:10px; padding:10px; border:1px solid #283041}
  .log p{margin:.4em 0}
  .controls{display:flex; flex-wrap:wrap; gap:8px}
  button{
    background:#141a28; border:1px solid #2a3347; color:var(--bright); padding:8px 10px; border-radius:10px; cursor:pointer;
    transition:transform .02s ease, background .2s ease, border-color .2s ease; font-weight:600;
  }
  button:hover{background:#192033; border-color:#3a4561}
  button:active{transform:translateY(1px)}
  button.primary{background:linear-gradient(180deg,#2a3559,#1a2340); border-color:#3b4a79}
  kbd{background:#111523; border:1px solid #2a3347; padding:2px 6px; border-radius:6px; font-family:var(--mono); color:#cfe3ff}
  .legend{display:grid; grid-template-columns:1fr 1fr; gap:6px; font-family:var(--mono); font-size:12px; color:var(--muted)}
  .legend span{display:flex; gap:6px; align-items:center}
  .badge{display:inline-grid; place-items:center; width:18px; height:18px; border-radius:4px; font-size:12px; background:#101523; border:1px solid #30405e}
  footer{grid-column:1/-1; text-align:center; color:var(--muted); font-size:12px}
  @media (max-width: 840px){
    .app{grid-template-columns:1fr}
  }
  /* Map glyph styles for HTML fallback (non-canvas) if needed */
  .mapgrid{display:grid; grid-template-columns: repeat(10, 1fr); gap:2px; font-family:var(--mono)}
  .sr-only{position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0}
</style>
</head>
<body>
<div class="app" role="application" aria-label="Tiny HTML RPG">
  <header>
    <div class="stat" aria-live="polite" aria-atomic="true">
      <strong>HP</strong>
      <div class="hpbar" title="Health"><i id="hpFill" style="width:100%"></i></div>
      <span id="hpText" class="pill">10/10</span>
    </div>
    <div class="stat" aria-live="polite" aria-atomic="true">
      <strong>XP</strong>
      <div class="xpbar" title="Experience"><i id="xpFill"></i></div>
      <span id="lvlText" class="pill">Lv 1</span>
    </div>
    <div class="stat"><strong>ATK</strong> <span id="atkText" class="pill">2</span></div>
    <div class="stat"><strong>DEF</strong> <span id="defText" class="pill">1</span></div>
    <div class="stat"><strong>Gold</strong> <span id="goldText" class="pill gold">0</span></div>
    <div class="stat"><strong>Potions</strong> <span id="potsText" class="pill">1</span></div>
    <div class="stat" title="Keyboard: arrows or WASD">
      <strong>Move</strong>&nbsp;<kbd>WASD</kbd>/<kbd>←↑↓→</kbd>
    </div>
  </header>

  <main>
    <div class="viewport">
      <canvas id="view" width="640" height="640" aria-label="Dungeon map" role="img"></canvas>
      <div class="sr-only" aria-live="polite" id="ariaStatus"></div>
    </div>
  </main>

  <section class="right">
    <div class="panel">
      <h3>Actions</h3>
      <div class="controls">
        <button class="primary" id="btnNew">New Run</button>
        <button id="btnSave">Save</button>
        <button id="btnLoad">Load</button>
        <button id="btnPotion">Drink Potion</button>
        <button id="btnHelp">Help</button>
      </div>
    </div>

    <div class="panel">
      <h3>Quest & Inventory</h3>
      <div id="quest">Find the stairs <span class="badge">&gt;</span>, defeat the floor boss <span class="badge">B</span>, and reach Floor 3.</div>
      <div style="margin-top:8px; font-family:var(--mono); color:var(--muted)" id="inv"></div>
      <div class="legend" style="margin-top:10px">
        <span><i class="badge">@</i> You</span>
        <span><i class="badge">G</i> Goblin</span>
        <span><i class="badge">S</i> Slime</span>
        <span><i class="badge">B</i> Boss</span>
        <span><i class="badge">T</i> Treasure</span>
        <span><i class="badge">&gt;</i> Stairs</span>
        <span><i class="badge">#</i> Wall</span>
        <span><i class="badge">.</i> Floor</span>
      </div>
    </div>

    <div class="panel">
      <h3>Event Log</h3>
      <div id="log" class="log" aria-live="polite" aria-atomic="false"></div>
    </div>
  </section>

  <footer>Made with plain HTML, CSS, and JavaScript. No libraries. Have fun!</footer>
</div>

<script>
(()=> {
  // --- Core data ------------------------------------------------------------
  const SIZE = 10;
  const TILE = 64; // canvas pixels per tile
  const glyphs = {
    empty:'.', wall:'#', player:'@', goblin:'G', slime:'S', treasure:'T', stairs:'>', boss:'B'
  };
  const colors = {
    bg:'#121826', grid:'#283041', floor1:'#1b2233', floor2:'#0f1420',
    wall:'#2f3b54', wallEdge:'#3b4a79',
    player:'#e2e8f0', goblin:'#22c55e', slime:'#22d3ee', treasure:'#f59e0b', stairs:'#a78bfa', boss:'#ef4444'
  };

  const state = {
    floor:1,
    player:{x:0,y:0,hp:10,maxHp:10,atk:2,def:1,lvl:1,xp:0,next:10,gold:0,potions:1},
    items:[], // {name, qty}
    map:[],   // 2D array of tiles
    units:[], // enemies etc. {type,hp,atk,def,x,y,xp,gold}
    stairs:{x:0,y:0},
    bossAlive:false,
    rng: mulberry32(Date.now() % 2**31)
  };

  // --- Utilities ------------------------------------------------------------
  function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15, t|1);t^=t+Math.imul(t^t>>>7, t|61);return ((t^t>>>14)>>>0)/4294967296}}
  function randi(min,max){return Math.floor(state.rng()*(max-min+1))+min}
  function choice(arr){return arr[Math.floor(state.rng()*arr.length)]}
  function clamp(n,min,max){return Math.max(min, Math.min(max,n))}
  function key(x,y){return x+','+y}
  const dirs = { 'ArrowUp':[0,-1],'ArrowDown':[0,1],'ArrowLeft':[-1,0],'ArrowRight':[1,0],
                 'KeyW':[0,-1],'KeyS':[0,1],'KeyA':[-1,0],'KeyD':[1,0] };

  // --- Map generation -------------------------------------------------------
  function newRun(){
    Object.assign(state.player,{hp:10,maxHp:10,atk:2,def:1,lvl:1,xp:0,next:10,gold:0,potions:1});
    state.items = [];
    state.floor = 1;
    generateFloor();
    clearLog();
    log(`Welcome, adventurer! Use WASD or arrows to move.`);
    log(`Quest: Reach Floor 3, clearing bosses.`);
    paint();
    syncUI();
  }

  function generateFloor(){
    // build empty map
    state.map = Array.from({length:SIZE}, ()=> Array.from({length:SIZE}, ()=> glyphs.empty));
    // outer walls
    for (let x=0;x<SIZE;x++){state.map[0][x]=glyphs.wall; state.map[SIZE-1][x]=glyphs.wall;}
    for (let y=0;y<SIZE;y++){state.map[y][0]=glyphs.wall; state.map[y][SIZE-1]=glyphs.wall;}
    // sprinkle inner walls
    const walls = 18 + state.floor*2;
    for (let i=0;i<walls;i++){
      const x=randi(1,SIZE-2), y=randi(1,SIZE-2);
      state.map[y][x]=glyphs.wall;
    }
    // ensure some paths by carving random walk
    let cx=randi(1,SIZE-2), cy=randi(1,SIZE-2);
    for (let i=0;i<80;i++){
      state.map[cy][cx]=glyphs.empty;
      const d = choice([[1,0],[-1,0],[0,1],[0,-1]]);
      cx = clamp(cx+d[0],1,SIZE-2); cy = clamp(cy+d[1],1,SIZE-2);
      state.map[cy][cx]=glyphs.empty;
    }
    // place player at an empty tile far from stairs later
    const empties = allEmpty();
    const p = choice(empties);
    state.player.x = p.x; state.player.y = p.y;

    // place stairs
    let s; do { s = choice(empties) } while (dist(p,s) < 8);
    state.stairs = s;
    state.map[s.y][s.x] = glyphs.stairs;

    // enemies
    state.units = [];
    const mobCount = 5 + state.floor;
    for (let i=0;i<mobCount;i++){
      let pos;
      do { pos = choice(empties) } while ((pos.x===p.x && pos.y===p.y) || (pos.x===s.x && pos.y===s.y) || state.units.some(u=>u.x===pos.x && u.y===pos.y));
      const type = (state.floor%2===0 ? choice(['goblin','slime']) : choice(['slime','goblin']));
      const stats = enemyStats(type);
      state.units.push({...stats, x:pos.x, y:pos.y});
    }
    // boss on floors 1 and 2; final boss on 3
    state.bossAlive = true;
    let bp;
    do { bp = choice(empties) } while (dist(bp, p) < 6 || (bp.x===s.x && bp.y===s.y));
    state.units.push({...enemyStats('boss'), x:bp.x, y:bp.y});

    // treasures
    const chestCount = 2 + Math.max(0, state.floor-1);
    for (let i=0;i<chestCount;i++){
      let tpos;
      do { tpos = choice(empties) } while (occupied(tpos.x,tpos.y) || (tpos.x===p.x && tpos.y===p.y) || (tpos.x===s.x && tpos.y===s.y));
      state.map[tpos.y][tpos.x] = glyphs.treasure;
    }
  }

  function enemyStats(type){
    const f = state.floor;
    if (type==='goblin') return {type, hp: 4+f, atk: 2+Math.floor(f/2), def:1, xp: 5+f, gold: randi(2,6)};
    if (type==='slime')  return {type, hp: 6+f, atk: 1+Math.floor(f/3), def:2, xp: 6+f, gold: randi(1,5)};
    if (type==='boss')   return {type, hp: 10+3*f, atk: 2+f, def:2+Math.floor(f/2), xp: 12+4*f, gold: randi(6,12)};
  }

  function allEmpty(){
    const arr=[];
    for (let y=1;y<SIZE-1;y++) for (let x=1;x<SIZE-1;x++)
      if (state.map[y][x]===glyphs.empty) arr.push({x,y});
    return arr;
  }
  function occupied(x,y){
    return state.units.some(u=>u.x===x && u.y===y);
  }
  function dist(a,b){return Math.abs(a.x-b.x)+Math.abs(a.y-b.y)}

  // --- Rendering ------------------------------------------------------------
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d');

  function paint(){
    const ts = TILE;
    // background
    ctx.fillStyle = colors.bg; ctx.fillRect(0,0,canvas.width,canvas.height);
    // checker floor and grid
    for (let y=0;y<SIZE;y++){
      for (let x=0;x<SIZE;x++){
        const even = (x+y)%2===0;
        ctx.fillStyle = even ? '#0f1626' : '#0c1220';
        ctx.fillRect(x*ts,y*ts,ts,ts);
        ctx.strokeStyle = colors.grid; ctx.globalAlpha = .12;
        ctx.strokeRect(x*ts+.5,y*ts+.5,ts-1,ts-1);
        ctx.globalAlpha = 1;
      }
    }
    // tiles
    for (let y=0;y<SIZE;y++){
      for (let x=0;x<SIZE;x++){
        const t = state.map[y][x];
        if (t===glyphs.wall){
          ctx.fillStyle = colors.wall; ctx.fillRect(x*ts,y*ts,ts,ts);
          ctx.strokeStyle = colors.wallEdge; ctx.strokeRect(x*ts+.5,y*ts+.5,ts-1,ts-1);
        }
        if (t===glyphs.treasure){
          drawGlyph('T', x,y, colors.treasure);
        }
        if (t===glyphs.stairs){
          drawGlyph('>', x,y, colors.stairs);
        }
      }
    }
    // units
    for (const u of state.units){
      if (u.type==='goblin') drawGlyph('G',u.x,u.y,colors.goblin);
      else if (u.type==='slime') drawGlyph('S',u.x,u.y,colors.slime);
      else drawGlyph('B',u.x,u.y,colors.boss);
    }
    // player
    drawGlyph('@', state.player.x, state.player.y, colors.player);

    // floor label
    ctx.fillStyle = 'rgba(0,0,0,.45)';
    ctx.fillRect(8,8,110,28);
    ctx.fillStyle = '#cbd5e1';
    ctx.font = 'bold 18px ' + (CSS.supports('font-family: Inter')?'Inter, ':'') + 'system-ui';
    ctx.fillText(`Floor ${state.floor}`, 16, 28);
  }

  function drawGlyph(g, x, y, color){
    const ts=TILE;
    ctx.fillStyle = color;
    ctx.font = 'bold 40px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
    ctx.textAlign = 'center'; ctx.textBaseline='middle';
    ctx.fillText(g, x*ts+ts/2, y*ts+ts/2+2);
  }

  // --- UI sync --------------------------------------------------------------
  const hpFill = document.getElementById('hpFill');
  const xpFill = document.getElementById('xpFill');
  const hpText = document.getElementById('hpText');
  const lvlText = document.getElementById('lvlText');
  const atkText = document.getElementById('atkText');
  const defText = document.getElementById('defText');
  const goldText = document.getElementById('goldText');
  const potsText = document.getElementById('potsText');
  const invDiv = document.getElementById('inv');
  const ariaStatus = document.getElementById('ariaStatus');

  function syncUI(){
    const p = state.player;
    hpText.textContent = `${p.hp}/${p.maxHp}`;
    hpFill.style.width = `${(p.hp/p.maxHp)*100}%`;
    xpFill.style.width = `${(p.xp/p.next)*100}%`;
    lvlText.textContent = `Lv ${p.lvl}`;
    atkText.textContent = p.atk;
    defText.textContent = p.def;
    goldText.textContent = p.gold;
    potsText.textContent = p.potions;
    invDiv.textContent = state.items.length ? 'Inventory: ' + state.items.map(i=>`${i.name} x${i.qty}`).join(', ') : 'Inventory: (empty)';
    ariaStatus.textContent = `HP ${p.hp} of ${p.maxHp}, Level ${p.lvl}, Gold ${p.gold}`;
  }

  // --- Input & turns --------------------------------------------------------
  window.addEventListener('keydown', e=>{
    if (dirs[e.code]){
      e.preventDefault();
      const [dx,dy] = dirs[e.code];
      tryStep(dx,dy);
    }
    if (e.code==='Space'){
      e.preventDefault();
      // Wait a turn (enemies move)
      enemyTurn();
      endTurn();
    }
  });

  document.getElementById('btnPotion').addEventListener('click', drinkPotion);
  document.getElementById('btnNew').addEventListener('click', ()=>{newRun();});
  document.getElementById('btnSave').addEventListener('click', saveGame);
  document.getElementById('btnLoad').addEventListener('click', loadGame);
  document.getElementById('btnHelp').addEventListener('click', ()=> {
    log(`Controls: Move with WASD/Arrows. Bump into an enemy to attack. <kbd>Space</kbd> to wait a turn. Potions heal 6 HP.`);
    log(`Win: Reach Floor 3's stairs after defeating bosses on each floor.`);
  });

  function tryStep(dx,dy){
    const p = state.player;
    const nx=p.x+dx, ny=p.y+dy;
    // bounds
    if (nx<0||ny<0||nx>=SIZE||ny>=SIZE) return;
    // wall
    if (state.map[ny][nx]===glyphs.wall){ log(`A wall blocks your path.`); return; }
    // enemy?
    const u = state.units.find(u=>u.x===nx && u.y===ny);
    if (u){
      attack(p,u);
      if (u.hp<=0){
        // loot
        const idx = state.units.indexOf(u);
        state.units.splice(idx,1);
        const gold = u.gold;
        p.gold += gold;
        p.xp += u.xp;
        log(`You defeated the ${u.type}! +${u.xp} XP, +${gold} gold.`);
        maybeDrop();
        checkLevelUp();
        if (u.type==='boss'){
          state.bossAlive = false;
          log(`Boss defeated! The air shimmers...`);
        }
      }
    } else {
      // move
      p.x=nx; p.y=ny;
      // tile effects
      const t = state.map[ny][nx];
      if (t===glyphs.treasure){
        state.map[ny][nx] = glyphs.empty;
        const reward = openChest();
        log(reward.msg);
      } else if (t===glyphs.stairs){
        if (state.bossAlive){
          log(`A strange force bars your way. The boss still lurks.`);
        } else {
          state.floor++;
          // win condition
          if (state.floor>3){
            log(`You step beyond the third floor. Victory! 🎉`);
            saveAuto('victory', true);
            // freeze movement by removing enemies and making stairs walls
            state.units.length=0;
            state.map[state.player.y][state.player.x]=glyphs.empty;
          } else {
            log(`You descend to Floor ${state.floor}.`);
            // scale player a bit
            state.player.maxHp += 2; state.player.hp = state.player.maxHp;
            state.player.atk += 1; // slight boost per floor
            generateFloor();
          }
        }
      }
    }
    // enemy turn after player acts (if game ongoing)
    if (state.floor<=3 && state.player.hp>0){
      enemyTurn();
    }
    endTurn();
  }

  function attack(attacker, defender){
    const hit = Math.max(0, attacker.atk + randi(0,2) - defender.def);
    defender.hp -= Math.max(1, hit);
    if (attacker===state.player){
      log(`You hit the ${defender.type} for ${Math.max(1,hit)}.`);
    } else {
      log(`The ${attacker.type} hits you for ${Math.max(1,hit)}.`);
    }
  }

  function enemyTurn(){
    const p = state.player;
    for (const u of state.units){
      // If adjacent, attack. Otherwise move toward player with simple path bias.
      const dx = Math.sign(p.x - u.x), dy = Math.sign(p.y - u.y);
      if (Math.abs(p.x-u.x)+Math.abs(p.y-u.y)===1){
        attack(u,p);
        if (p.hp<=0){ log(`You have fallen... 💀`); break; }
      } else {
        // try step in a shuffled priority
        const options = state.rng()<0.5 ? [[dx,0],[0,dy]] : [[0,dy],[dx,0]];
        for (const [mx,my] of options){
          const nx=u.x+mx, ny=u.y+my;
          if (!walkable(nx,ny)) continue;
          if (occupied(nx,ny) || (nx===p.x && ny===p.y)) continue;
          u.x=nx; u.y=ny; break;
        }
      }
    }
  }
  function walkable(x,y){
    if (x<0||y<0||x>=SIZE||y>=SIZE) return false;
    const t=state.map[y][x];
    return t!==glyphs.wall;
  }

  function endTurn(){
    // small chance of ambient message
    if (state.rng() < 0.05) ambient();
    // redraw + UI
    paint();
    syncUI();
    // check death
    if (state.player.hp<=0){
      log(`Run over. Click "New Run" to try again.`);
    }
  }

  function ambient(){
    const lines = [
      'You hear distant dripping.',
      'A draft chills your neck.',
      'Coins clink somewhere nearby.',
      'Your torch flickers.',
      'Scratching echoes in the dark.'
    ];
    log(choice(lines));
  }

  function maybeDrop(){
    const p = state.player;
    if (state.rng()<0.4){
      const roll = state.rng();
      if (roll<0.5){ p.potions++; log(`You found a potion.`); }
      else { const g = randi(3,8); p.gold+=g; log(`You scoop ${g} extra gold.`);}
    }
  }

  function openChest(){
    const roll = state.rng();
    if (roll < .35){ state.player.potions++; return {msg:`A potion nestled in velvet. +1 potion.`}; }
    if (roll < .7){
      const g = randi(5,16); state.player.gold += g; return {msg:`A tidy sum of coins. +${g} gold.`};
    }
    // equipment
    const equips = [
      {name:`Iron Ring (+1 DEF)`, def:1},
      {name:`Bronze Blade (+1 ATK)`, atk:1},
      {name:`Gleaming Charm (+2 MAX HP)`, maxHp:2},
    ];
    const eq = choice(equips);
    if (eq.def){ state.player.def += eq.def; }
    if (eq.atk){ state.player.atk += eq.atk; }
    if (eq.maxHp){ state.player.maxHp += eq.maxHp; state.player.hp = Math.min(state.player.maxHp, state.player.hp+eq.maxHp); }
    addItem(eq.name);
    return {msg:`Treasure! You obtained ${eq.name}.`};
  }

  function addItem(name){
    const it = state.items.find(i=>i.name===name);
    if (it) it.qty++; else state.items.push({name, qty:1});
  }

  function checkLevelUp(){
    const p=state.player;
    while (p.xp >= p.next){
      p.xp -= p.next;
      p.lvl++;
      p.next = Math.floor(p.next * 1.6);
      const gain = choice(['atk','def','hp']);
      if (gain==='atk'){ p.atk += 1; log(`Level up! ATK +1`); }
      else if (gain==='def'){ p.def += 1; log(`Level up! DEF +1`); }
      else { p.maxHp += 3; p.hp = p.maxHp; log(`Level up! Max HP +3 (fully healed)`); }
    }
  }

  function drinkPotion(){
    const p=state.player;
    if (p.potions<=0){ log(`No potions left.`); return; }
    p.potions--;
    const heal = Math.min(6, p.maxHp - p.hp);
    p.hp += heal;
    log(`You drink a potion and recover ${heal} HP.`);
    endTurn();
  }

  // --- Logging --------------------------------------------------------------
  const logDiv = document.getElementById('log');
  function log(html){
    const p = document.createElement('p'); p.innerHTML = html;
    logDiv.appendChild(p);
    logDiv.scrollTop = logDiv.scrollHeight;
  }
  function clearLog(){ logDiv.innerHTML=''; }

  // --- Save / Load ----------------------------------------------------------
  function saveGame(){
    const save = JSON.stringify(state, (k,v)=>{
      if (k==='rng') return undefined; // skip function
      return v;
    });
    localStorage.setItem('tinyRPG.save', save);
    log(`Game saved.`);
  }
  function loadGame(){
    const raw = localStorage.getItem('tinyRPG.save');
    if (!raw){ log(`No save found.`); return; }
    const obj = JSON.parse(raw);
    // carefully copy back
    const keep = ['floor','player','items','map','units','stairs','bossAlive'];
    for (const k of keep) state[k] = obj[k];
    state.rng = mulberry32(Date.now() % 2**31);
    log(`Save loaded.`);
    paint(); syncUI();
  }
  function saveAuto(key, val){
    const exists = JSON.parse(localStorage.getItem('tinyRPG.meta')||'{}');
    exists[key]=val;
    localStorage.setItem('tinyRPG.meta', JSON.stringify(exists));
  }

  // --- Boot -----------------------------------------------------------------
  newRun();
})();
</script>
</body>
</html>